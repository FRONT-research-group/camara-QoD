# generated by datamodel-codegen:
#   filename:  quality-on-demand.yaml
#   timestamp: 2025-10-09T12:20:12+00:00

#from quality-on-demand.yaml generated

from __future__ import annotations

from enum import Enum
from ipaddress import IPv4Address, IPv6Address
from typing import Annotated, Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import AnyUrl, AwareDatetime, BaseModel, Field, RootModel


class XCorrelator(RootModel[str]):
    root: Annotated[str, Field(
        pattern=r'^[a-zA-Z0-9-_:;.\/<>{}]{0,256}$',
        description='Value for the x-correlator',
        examples=['b4333c46-49c0-4f62-80d7-f0ef930f1c46'],
    )]


class SessionId(RootModel[UUID]):
    root: UUID = Field(..., description='Session ID in UUID format')


class Port(RootModel[int]):
    root: Annotated[int, Field(ge=0, le=65535, description='TCP or UDP port number')]


class Range(BaseModel):
    from_: Port = Field(..., alias='from')
    to: Port


class PortsSpec(BaseModel):
    ranges: Optional[List[Range]] = Field(
        None, description='Range of TCP or UDP ports', min_length=1
    )
    ports: Optional[List[Port]] = Field(
        None, description='Array of TCP or UDP ports', min_length=1
    )


class CredentialType(Enum):
    PLAIN = 'PLAIN'
    ACCESSTOKEN = 'ACCESSTOKEN'
    REFRESHTOKEN = 'REFRESHTOKEN'


class SinkCredential(BaseModel):
    credentialType: CredentialType = Field(
        ...,
        description='The type of the credential.\nNote: Type of the credential - MUST be set to ACCESSTOKEN for now\n',
    )


class PlainCredential(SinkCredential):
    identifier: str = Field(
        ..., description='The identifier might be an account or username.'
    )
    secret: str = Field(
        ..., description='The secret might be a password or passphrase.'
    )


class AccessTokenType(Enum):
    bearer = 'bearer'


class AccessTokenCredential(SinkCredential):
    accessToken: str = Field(
        ...,
        description='REQUIRED. An access token is a previously acquired token granting access to the target resource.',
    )
    accessTokenExpiresUtc: AwareDatetime = Field(
        ...,
        description='REQUIRED. An absolute (UTC) timestamp at which the token shall be considered expired. Token expiration should occur\nafter the termination of the requested session, allowing the client to be notified of any changes during the\nsessions\'s existence. If the token expires while the session is still active, the client will stop receiving notifications.\nIf the access token is a JWT and registered "exp" (Expiration Time) claim is present, the two expiry times should match.\nIt must follow [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) and must have time zone.\n',
        examples=['2023-07-03T12:27:08.312Z'],
    )
    accessTokenType: AccessTokenType = Field(
        ...,
        description='REQUIRED. Type of the access token (See [OAuth 2.0](https://tools.ietf.org/html/rfc6749#section-7.1)). For the current version of the API the type MUST be set to `Bearer`.',
    )


class RefreshTokenCredential(SinkCredential):
    accessToken: str = Field(
        ...,
        description='REQUIRED. An access token is a previously acquired token granting access to the target resource.',
    )
    accessTokenExpiresUtc: AwareDatetime = Field(
        ...,
        description='REQUIRED. An absolute UTC instant at which the token shall be considered expired.\nIf the access token is a JWT and registered "exp" (Expiration Time) claim is present, the two expiry times should match.\nIt must follow [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) and must have time zone.\n',
    )
    accessTokenType: AccessTokenType = Field(
        ...,
        description='REQUIRED. Type of the access token (See [OAuth 2.0](https://tools.ietf.org/html/rfc6749#section-7.1)).',
    )
    refreshToken: str = Field(
        ...,
        description='REQUIRED. An refresh token credential used to acquire access tokens.',
    )
    refreshTokenEndpoint: AnyUrl = Field(
        ...,
        description='REQUIRED. A URL at which the refresh token can be traded for an access token.',
    )


class ExtendSessionDuration(BaseModel):
    requestedAdditionalDuration: Annotated[int, Field(ge=1)] = Field(
        ...,
        description='Additional duration in seconds to be added to the current session duration. The overall session duration, including extensions, shall not exceed the maximum duration limit for the QoS Profile.\n',
        examples=[1800],
    )


class QosProfileName(
    RootModel[str]
):
    root: Annotated[str, Field(
        pattern=r'^[a-zA-Z0-9_.-]+$',
        min_length=3,
        max_length=256
    )] = Field(
        ...,
        description='A unique name for identifying a specific QoS profile.\nThis may follow different formats depending on the API provider implementation.\nSome options addresses:\n  - A UUID style string\n  - Support for predefined profiles QOS_S, QOS_M, QOS_L, and QOS_E\n  - A searchable descriptive name\nThe set of QoS Profiles that an API provider is offering may be retrieved by means of the QoS Profile API (qos-profile) or agreed on onboarding time.\n',
        examples=['voice'],
    )


class Type(Enum):
    org_camaraproject_quality_on_demand_v1_qos_status_changed = (
        'org.camaraproject.quality-on-demand.v1.qos-status-changed'
    )


class Specversion(Enum):
    field_1_0 = '1.0'


class Datacontenttype(Enum):
    application_json = 'application/json'


class CloudEvent(BaseModel):
    id: str = Field(
        ...,
        description='Identifier of this event, that must be unique in the source context.',
    )
    source: str = Field(
        ...,
        description='Identifies the context in which an event happened in the specific provider implementation.',
    )
    type: Type = Field(..., description='The type of the event.')
    specversion: Specversion = Field(
        ...,
        description='Version of the specification to which this event conforms (must be 1.0 if it conforms to Cloudevents 1.0.2 version)',
    )
    datacontenttype: Optional[Datacontenttype] = Field(
        None,
        description='media-type that describes the event payload encoding, must be "application/json" for CAMARA APIs',
    )
    data: Optional[Dict[str, Any]] = Field(
        None,
        description='Event notification details payload, which depends on the event type',
    )
    time: AwareDatetime = Field(
        ...,
        description='Timestamp of when the occurrence happened. It must follow [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) and must have time zone.\n',
    )


class StatusInfo(Enum):
    DURATION_EXPIRED = 'DURATION_EXPIRED'
    NETWORK_TERMINATED = 'NETWORK_TERMINATED'
    DELETE_REQUESTED = 'DELETE_REQUESTED'


class NetworkAccessIdentifier(RootModel[str]):
    root: str = Field(
        ...,
        description='A public identifier addressing a subscription in a mobile network. In 3GPP terminology, it corresponds to the GPSI formatted with the External Identifier ({Local Identifier}@{Domain Identifier}). Unlike the telephone number, the network access identifier is not subjected to portability ruling in force, and is individually managed by each operator.',
        examples=['123456789@domain.com'],
    )


class PhoneNumber(RootModel[str]):
    root: Annotated[str, Field(
        pattern=r'^\+[1-9][0-9]{4,14}$'
    )] = Field(
        ...,
        description="A public identifier addressing a telephone subscription. In mobile networks it corresponds to the MSISDN (Mobile Station International Subscriber Directory Number). In order to be globally unique it has to be formatted in international format, according to E.164 standard, prefixed with '+'.",
        examples=['+123456789'],
    )


class SingleIpv4Addr(RootModel[IPv4Address]):
    root: IPv4Address = Field(
        ...,
        description='A single IPv4 address with no subnet mask',
        examples=['203.0.113.0'],
    )


class DeviceIpv6Address(RootModel[IPv6Address]):
    root: IPv6Address = Field(
        ...,
        description='The device should be identified by the observed IPv6 address, or by any single IPv6 address from within the subnet allocated to the device (e.g. adding ::0 to the /64 prefix).\n\nThe session shall apply to all IP flows between the device subnet and the specified application server, unless further restricted by the optional parameters devicePorts or applicationServerPorts.\n',
        examples=['2001:db8:85a3:8d3:1319:8a2e:370:7344'],
    )


class ApplicationServerIpv4Address(RootModel[str]):
    root: str = Field(
        ...,
        description='IPv4 address may be specified in form <address/mask> as:\n  - address - an IPv4 number in dotted-quad form 1.2.3.4. Only this exact IP number will match the flow control rule.\n  - address/mask - an IP number as above with a mask width of the form 1.2.3.4/24.\n    In this case, all IP numbers from 1.2.3.0 to 1.2.3.255 will match. The bit width MUST be valid for the IP version.\n',
        examples=['198.51.100.0/24'],
    )


class ApplicationServerIpv6Address(RootModel[str]):
    root: str = Field(
        ...,
        description='IPv6 address may be specified in form <address/mask> as:\n  - address - The /128 subnet is optional for single addresses:\n    - 2001:db8:85a3:8d3:1319:8a2e:370:7344\n    - 2001:db8:85a3:8d3:1319:8a2e:370:7344/128\n  - address/mask - an IP v6 number with a mask:\n    - 2001:db8:85a3:8d3::0/64\n    - 2001:db8:85a3:8d3::/64\n',
        examples=['2001:db8:85a3:8d3:1319:8a2e:370:7344'],
    )


class QosStatus(Enum):
    REQUESTED = 'REQUESTED'
    AVAILABLE = 'AVAILABLE'
    UNAVAILABLE = 'UNAVAILABLE'


class EventQosStatus(Enum):
    AVAILABLE = 'AVAILABLE'
    UNAVAILABLE = 'UNAVAILABLE'


class ErrorInfo(BaseModel):
    status: int = Field(..., description='HTTP response status code')
    code: str = Field(..., description='A human-readable code to describe the error')
    message: str = Field(
        ..., description='A human-readable description of what the event represents'
    )


class Data(BaseModel):
    sessionId: SessionId
    qosStatus: EventQosStatus
    statusInfo: Optional[StatusInfo] = None


class EventQosStatusChanged(CloudEvent):
    data: Data = Field(..., description='Event details depending on the event type')


class ApplicationServer(BaseModel):
    ipv4Address: Optional[ApplicationServerIpv4Address] = None
    ipv6Address: Optional[ApplicationServerIpv6Address] = None


class DeviceIpv4Addr1(BaseModel):
    publicAddress: SingleIpv4Addr
    privateAddress: SingleIpv4Addr
    publicPort: Optional[Port] = None


class DeviceIpv4Addr2(BaseModel):
    publicAddress: SingleIpv4Addr
    privateAddress: Optional[SingleIpv4Addr] = None
    publicPort: Port


class DeviceIpv4Addr(RootModel[Union[DeviceIpv4Addr1, DeviceIpv4Addr2]]):
    root: Union[DeviceIpv4Addr1, DeviceIpv4Addr2] = Field(
        ...,
        description='The device should be identified by either the public (observed) IP address and port as seen by the application server, or the private (local) and any public (observed) IP addresses in use by the device (this information can be obtained by various means, for example from some DNS servers).\n\nIf the allocated and observed IP addresses are the same (i.e. NAT is not in use) then  the same address should be specified for both publicAddress and privateAddress.\n\nIf NAT64 is in use, the device should be identified by its publicAddress and publicPort, or separately by its allocated IPv6 address (field ipv6Address of the Device object)\n\nIn all cases, publicAddress must be specified, along with at least one of either privateAddress or publicPort, dependent upon which is known. In general, mobile devices cannot be identified by their public IPv4 address alone.\n',
        examples=[{'publicAddress': '203.0.113.0', 'publicPort': 59765}],
    )


class BaseSessionInfo(BaseModel):
    applicationServer: ApplicationServer
    devicePorts: Optional[PortsSpec] = Field(
        None,
        description='The ports used locally by the device for flows to which the requested QoS profile should apply. If omitted, then the qosProfile will apply to all flows between the device and the specified application server address and ports',
    )
    applicationServerPorts: Optional[PortsSpec] = Field(
        None,
        description='A list of single ports or port ranges on the application server',
    )
    qosProfile: QosProfileName
    sink: Optional[AnyUrl] = Field(
        None,
        description='The address to which events about all status changes of the session (e.g. session termination) shall be delivered using the selected protocol.',
        examples=['https://endpoint.example.com/sink'],
    )
    sinkCredential: Optional[SinkCredential] = Field(
        None,
        description='A sink credential provides authentication or authorization information necessary to enable delivery of events to a target.',
    )


class Device(BaseModel):
    phoneNumber: Optional[PhoneNumber] = None
    networkAccessIdentifier: Optional[NetworkAccessIdentifier] = None
    ipv4Address: Optional[DeviceIpv4Addr] = None
    ipv6Address: Optional[DeviceIpv6Address] = None


DeviceResponse = Device


class RetrieveSessionsInput(BaseModel):
    device: Optional[Device] = None


class SessionInfo(BaseSessionInfo):
    device: Optional[DeviceResponse] = Field(
        None,
        description='Disambiguates the device to which the session applies when multiple device identifiers were provided',
    )
    sessionId: SessionId
    duration: Annotated[int, Field(ge=1)] = Field(
        ...,
        description='Session duration in seconds. Implementations can grant the requested session duration or set a different duration, based on network policies or conditions.\n- When `qosStatus` is "REQUESTED", the value is the duration to be scheduled, granted by the implementation.\n- When `qosStatus` is AVAILABLE", the value is the overall duration since `startedAt. When the session is extended, the value is the new overall duration of the session.\n- When `qosStatus` is "UNAVAILABLE", the value is the overall effective duration since `startedAt` until the session was terminated.\n',
        examples=[3600],
    )
    startedAt: Optional[AwareDatetime] = Field(
        None,
        description='Date and time when the QoS status became "AVAILABLE". Not to be returned when `qosStatus` is "REQUESTED". It must follow [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) and must have time zone.',
        examples=['2024-06-01T12:00:00Z'],
    )
    expiresAt: Optional[AwareDatetime] = Field(
        None,
        description='Date and time of the QoS session expiration. It must follow [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) and must have time zone.\n- When `qosStatus` is "AVAILABLE", it is the limit time when the session is scheduled to finnish, if not terminated by other means.\n- When `qosStatus` is "UNAVAILABLE", it is the time when the session was terminated.\n- Not to be returned when `qosStatus` is "REQUESTED".\nWhen the session is extended, the value is the new expiration time of the session.\n',
        examples=['2024-06-01T13:00:00Z'],
    )
    qosStatus: QosStatus
    statusInfo: Optional[StatusInfo] = None


class CreateSession(BaseSessionInfo):
    device: Optional[Device] = None
    duration: Annotated[int, Field(ge=1)] = Field(
        ...,
        description='Requested session duration in seconds. Value may be explicitly limited for the QoS profile, as specified in the Qos Profile (see qos-profile API). Implementations can grant the requested session duration or set a different duration, based on network policies or conditions.\n',
        examples=[3600],
    )


class RetrieveSessionsOutput(RootModel[List[SessionInfo]]):
    root: List[SessionInfo] = Field(
        ..., description='QoS session information for a given device', min_length=0
    )
